-Angular Installation:
    Install node js.
    After it is installed, for mac, run the following line in terminal:
    $ sudo npm install -g @angular/cli@latest

-Creating a new project:
    First cd into desired directory then run the following line in terminal:
    $ ng new <appName>

-Running the server:
    Run the following:
    $ ng serve

-Directives:
    [(ngModel)] = "varName"         // This is a directive which stores the info in the specified variable.

-Adding Bootstrap and saving it in the Project:
    cd to the project folder.
    Use the following command to download bootstrap for the project using npm manager:
    $ npm install --save bootstrap@3
    This will only save bootstrap for that perticular project.
    Adding Bootstrap to style.css file:
        Add the following to style.css :
            @import "~bootstrap/dist/css/bootstrap.css"

-Working of Angular:
    We first start with the index.html file. This is the html file which is displayed in the browser.
    When this page is loaded, a file named main.ts is executed with it.
    In main.ts, there is a "bootstrapModule" which passes the imported "AppModule" as an argument.
    In 'app.module.ts' file, 'AppComponent' is passed in the 'bootstrap' array which tells angular to include all the 'app.component' files in the project.
    Angular now can read all the 'app.component' files.
    'app.component.ts' file contains a decorator '@Component' under which there is a variable named 'selector'.
    The specified 'selector acts as an html tag under which all the content in the 'app.component.html' file is included in the 'index.html' file.

-Creating a Component:
    To create a component for a specific app, inside the app folder, create a folder with the name same as the component name.
    Create a file inside the folder named as 'componentName.component.ts'.
    Now, inside this file, first we need to import the 'Component' element so that js compiler should know what the '@Component' means.
    To include the 'Component', type the following in the ts file:
    -> import { Component } from '@angular/core';
    Then declare the '@Component' decorator and add its deatils as follows:
    -> @Component({
            selector: 'app-name',
            templateUrl: './name.component.html'        //For this, there must be a name.component.html file in the component folder which contains the content of the component.
        })
    Then we need to enter the following statement:
    -> export class NameComponent { }

-Adding the created component to the app.module.ts file:
    To include the component to our project, we need to make changes in the app.module.ts file.
    We first import our created module using following statement:
    -> import { NameComponent } from './name/name.component';       //includes your component to the ts file
    Now under declarations, Enter the name of your component as 'NameComponent'.
    Now our component is registered and ready to use.

-Using created Components:
    The created components can only be used in the app.component.html file.
    It can be used using the selector as a html tag which we defined for the component.

-Creating Component using CLI:
    $ ng generate component compName        or          $ ng g c compName
    This will automatically create a folder in the apps folder with the name of the component and will automatically make the necessary changes in the app.module.ts file.

-> One component can be used in the other component with the help of its selector.

-Using Inline HTML:
    To use inline html instead of specifying a template in the templateUrl in component.ts file, use template and assign it with the html code wrapped in quotes.
    To use multiline inline html, wrap the html with backtic ( ` ) instead of quotes.

-Different ways of using selectors:
    By default, when we mention the selector's name in quotes in the component.ts file, we use the selector as an element in the template file.
    There are more ways to use a selector.
    -> Use selector as a class:
        Inside the quotes of the selector variable, use '.selectorName' to use the selector as a class same as in css.
    ->Use selector as an attribute:
        Wrap the name of the selector with square brackets ( [] ) to use the selector as an attribute of any html tag.

-Data Binding:
    It refers to the communication between the typescript file and the template (HTML) file.
    There are different forms of data binding:
        Output data binding:
            -String Interpolation
            -Property Binding
        Input data binding:
            -Event Binding
        Two-way Binding

-String Interpolation:
    This allows us to use the variables declared in the class in the component.ts file in the template file.
    To call the variable, use {{}} and inside it input the name of the variable or the method which returns a string.

-Property Binding:
    It is used to control the html block using the code in the component.ts file.
    We can bind a HTML Attribute with a function defined in the .ts file using property binding.
    For eg:
        Disabled attribute for button tag can be binded to a function which enables the button after 2 seconds of the pageload using property binding.
        To use property binding here, we use the following syntax where we place the disabled attribute:
            [disabled]="funcName"
        Here, funcName will be replaced by a function which will set a timeout of 2 seconds for the button.

-Event Binding:
    It is used to execute the code block as per the action commited by the user(for eg. click of a button).
    To use event binding, inside a html tag, use paranthesis (inside these, name of the event, such as click, mouseover, etc) and set it equal to the function name or a small block of code inside the quotes.
    To dynamically display the text which user types in a text box using event binding:
        First we create a input type text and in its attributes, we create an event binding (input)="funcName($event)"      //Notice the argument $event
        The argument $event helps to fetch the value dynamically from the text box and keep on updating value using the defined function in the typescript file.

-Two way data binding:
    As the name suggests, it can change both the input and the output data dynamically.
    This is used by using [(ngModel)] = "varName";
    It will change the value of the html element with the two way data binding to the varName as well as it can change the value of varName to whatever user defines it in the html element.

-Directives:
    Prebuilt Directives:
        *ngIf = "true/false"        // * is used for structural directives, i.e. which adds or removes the element from the DOM
        Usage of else with ngIf:
            eg: <p *ngIf="true/false; else localVarName"> Some Text </p>         // localVarName is used to refer the ng-template tag with the local referal named localVarName
                <ng-template #localVarName>         // # is used for local referal
                    Some Text
                </ng-template>
                Here ng-template tag is used as a substitute element which will be present in the DOM if else condition is true.
        [ngStyle] = "{ propertyName: 'value' }"         // ngStyle is a builtin attribute directive which is binded to the element with property binding
        [ngClass] = "{ className: condition }"      //another attribute directive, changes classes dynamically
        *ngFor = "let varName of listName"          //a structural directive, can add elements dynamically

-Sharing of a property between components:
    Angular has a functionality to share a property of a component to all the components where the selector of the component, of which the property is to be shared, is used.
    To share a property, do the following:
        Go to the component.ts file which has the property to be shared.
        import { Input } from '@angular/core'.          //Input is a decorator which is placed before the property which can now get input from other components
        Now, before the property declaration, use @Input() propertyName = 'something';
        @Input decorator enables for the property to be used under the selector tag of the component which has the property that has been shared.
        We can also assign an alias for the property name to be used outside of the component. To do so:
            Just pass the aliasName as a argument in the @Input() decorator. eg: @Input('aliasName')

-Catching an event from other components:
    To catch an event from other components and to fetch data along with it, Do the following:
        Create emitable event property (emitable object).
        Example:
            @Output() propName = new EventEmitter<{data: datatype}>();          // here EventEmitter is an object which emits the data inside the <{}> to other components where these EventEmitter objects are used as event binding
            To use EventEmitter and Output, both must be imported from '@angular/core'.     // @Output is a decorator which is used to send the data of the property from this component to another component
        To emit the property out of the component, use the following:
            this.propName.emit({data: dataValue});
        Now, to catch the emitted data, the EventEmitter objects can be used as the event listner via event binding with the selector for the component which has the EventEmitter objects.
        To do so, do the following:
            <selectorName (propName)="funcName($event)"></selectorName>
            Here, propName is the EventEmitter object emitted from the other component, funcName is the function which fetches the values emitted by those objects.
    Alias for the EventEmitter can be used in the same way as in @Input decorator, for the @Output decorator.

-View Encapsulation:
    By default, Angular restricts to apply the defined styles in the css file of the root app to all the components.
    The components will by default only follow the styles which are defined in their css file.
    Angular,by default, adds a unique attribute to all the html tags of a component.html file when seen in the inspect tool in the browser.
    To override this behavior, or to say, to expose a component to follow the styles of the app-root component, do the following:
        Go to the component.ts file of the component.
        Under the @Component decorator, add the following:
            encapsulation: ViewEncapsulation.none       // also import ViewEncapsulation from '@angular/core'
            None here implies that the styles defined in the css file of the component are applied globally to the angular app.
            None can be replaced by Native or Emulated.
            Emulated here implies to use ViewEncapsulation, which is already done by Angular by default, so there is no need to add encapsulation property to the @Component decorator.
            Native is the same as Emulated, but is not supported by all the browsers, which is why its better to use Emulated.

-Using Local References in Templates:
    Local References are holders which are used to fetch the HTMLInputElement, i.e. the whole HTML tag, not just its value.
    Local References can be used only in the template file.
    Example:
        <input type="text" #refVarName>
        Here, # is used to define a local reference variable.
        The variable name, followed by '#', can now be used anywhere in the template file.
        For Example, if we pass a local reference variable as a function argument, it will pass the whole html element as an argument, not only its value.
        To fetch the value of the html element, simply type refVarName.value either in the template file or in the typescript file.

-Accessing Template using @ViewChild:
    Another method to fetch the value of any html element is by using a local reference and @ViewChild.
    @ViewChild is a decorator placed before a property in a typescript file to convert the property to the type ElementRef.
    To convert a property to type ElementRef, do the following:
        Place a local reference on a html element.
        In the typescript file, create a property as follows:
            @ViewChild('localRefVarName') propertyName: ElementRef;
        Here ViewChild and ElementRef needs to be imported from '@angular/core'.
    Now, to get ElementRef object's value, use the following:
        propertyName.nativeElement.value

-Projecting content into components using ng-content:
    By default, Angular ignores everything which is placed between the opening and closing tags of the selector of a component.
    If we want that component to be displayed at a specific position in the template file of that component, simply add <ng-content></ng-content> in the template file of the component.
    Now all the data between the opening and closing tags of the selector of the component will be displayed as the part of the template file of the component where the ng-content element is placed.

-Component Lifecycle:
    There are several phases or so called activities in a component, from its initiation to any changes made in it.
    These phases are refered to as several so called functions which run on their own when a specific phase, for example: any changes made in a component, is reached.
    If a user want to perform certain activity at a perticular phase, he can include lines of code in those functions which are executed in those phases.
    There are several types of Functions which are executed on several phases.
    These functions can be stated inside the component class.
    The functions and their instant of execution are defined below:
        ngOnChanges(changes: SimpleChanges): called after a bound input property changes. This is the only Lifecycle function that recives an argument as mensioned with the functionName.
        ngOnInit(): called once the component is initialized. Is executed after the constructor.
        ngDoCheck(): called during every change detection run.
        ngAfterContentInit(): called after content has been projected into the view via ng-content.
        ngAfterContentChecked(): called every time the project content has been checked.
        ngAfterViewInit(): called after the component's view and child views have been initialized.
        ngAfterViewChecked(): called every time the view and child views have been checked.
        ngOnDestroy(): called when an element is removed from the DOM.
    These Lifecycle components need to be imported from '@angular/core'.
    If you want, you can specify in the defination of the class that which Lifecycle component is defined for the component. 
        For example:
            export class compNameComponent implements OnInit, OnChanges {}      //here OnInit and OnChanges is specified after the keyword 'implements'
    Notes on working of these functions:
        ngOnChanges executes before ngOnInit.
        If we console.log the SimpleChanges argument of ngOnChanges, we will see a SimpleChanges object which has the information regarding the past changes or the current version of change made to the component.

-Getting access to ng-content using @ContentChild:
    We can access the html elements, between the selector tags of a component, from the typescript file using @ContentChild.
    It is used in the same way as @ViewContent, setting a local reference, passing the localReference as the argument of @ContentChild decorator and accessing the element in the form of ElementRef object.
    @ContentChild needs to be imported form '@angular/core'.

-Directives:
    Directives are attributes that can be applied on an element which can change the properties of the element.
    To create directives:
        Inside the app folder, Create a folder with the name of the Directive.
        Create a file named 'directiveName.directive.ts'.
        To let Angular know about our directive, do the following:
            Goto app.module.ts file.
            In the declarations list, add directiveNameDirective.
            Also add the import for the directive file.
        Inside the typescript file, create a class with the name 'directiveNameDirective'.
        Put '@Directive' decorator on the top of the class.         //Directive needs to be imported from '@angular/core'
        In the argument of @Directive following properties are defined:
            @Directive({
                selector: '[selectorName]'          // square brackets makes this selector an attribute
            })
        Inside the class, we define a constructor as follows:
            constructor(private elementRef: ElementRef) {}
            Here, elementRef helps us access the html element and its properties in the typescript file itself.
        Now, we define ngOnInit, also add it in 'implements', and inside it, we can define the functionality of our directive.
        For example:
            ngOnInit() { this.elementRef.nativeElement.style.backgroundColor = 'green'; }
            This adds the functionality to change the backgroundColor to green of the element which has our directive.
    Directives can also be created using AngularCLI via executing the following line in the terminal:
        $ ng generate directive directiveName       or      ng g d directiveName
        This will generate a directive.ts file and a spec file for the same in the root of app folder which can be moved to desired locations which further their path needs to be informed to the 'app.module.ts'.
    To use this directive in a template file, just add the directive selector's name as an attribute in the element.
    For example:
        <p directiveName> </p>
    Using Renderer To Built a better AttributeDirective:
        Accessing the DOM using ElementRef object is not a good practice.
        So Renderer can be used for the same.
        Renderer is also used to set functionality of the directive.
        To use Renderer, do the following:
            Define a constructor as follows:
                constructor(private elRef: ElementRef, private renderer: Renderer2) {}
            Now use renderer in ngOnInit as follows:
                this.renderer.setStyle(this.elRef.nativeElement, 'propertyName(for example backgroundColor)', 'propertyValue');
    @HostListner:
        @HostListner decorator can be used inside a directive typescript file.
        This decorator gives us a functionality to set an event to happen when certain event happens on the element where our directive is used.
        Inside the class defination, Use this as following:
            @HostListner('eventName') eventNameFunc(eventData: Event) {         // here eventName is an event recognized by the DOM. For eg: click, mouseenter, mouseleave, etc
                // here we can set the events to occur on the element when the eventNameFunc occurs on the element.
            }
        HostListner needs to be imported From '@angular/core'.
    @HostBinding:
        This decorator can be used to bind a property of the host element to a property in the typescript file so that we can easily change that property of the host element by simply changing the value of the property assigned to the property with the @HostBinding decorator.
        For example:
            @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';
            Here, backgroundColor is a property name assigned with the value that is to be set for the property of the host element which is passed as an argument in the decorator.
            Now, this.backgroundColor can be called anywhere in the class to assign a new value to the backgroundColor property of the host element.
            Initially in this defination, backgroundColor is given any value to avoid any errors.
        HostBinding needs to be imported from '@angular/core'.
    -Interpretation of '*' in some structural directives:
        * before ngIf implies that ngIf is a structural directive, i.e. can bring change in the DOM itself.
        Although what it really does behind the scenes is, it passes the ngIf property via property binding(square brackets) in the element '<ng-template>'.
        For example:
            <ng-template [ngIf]="true/false">
                some content
            </ng-template>
            Here, ngIf is a property of ng-template element. ng-template renders within the DOM only when the nfIf condition is set true.
    -Building our own structural directive:
        Steps:
            Generate a directive either manually pr by using CLI command.
            In the directive.ts file, do the following:
                Inject the TemplateRef and ViewContainerRef argument in the constructor as follows:
                    constructor(private templateRef: TemplateRef, private vcRef: ViewContainerRef) {}
                    TemplateRef is used to access the Template inside the element on which this directive is used.
                    ViewContainerRef is used to mark the location of the element on which this directive is used.
                    Later these helps in the manupilation of the ViewContainer of the element in the DOM.
                Define a property inside the class which recieves the condition for the directive to take action.
                Define the property as per the following example:
                    @Input() set directiveName(condition: boolean) {        //set here specifies that directiveName will be a method which will return the element of the DOM
                        if(!condition) {            // directive functionality
                            this.vcRef.createEmbeddedView(this.templateRef);        // this method is used to insert the template in the templateRef property into the vcRef which will then be shown in the DOM
                        }   else {
                            this.vcRef.clear();     // this method clears the ViewContainer from the DOM
                        }
                    }
                Now as we use *ngIf, we can use our custom structural directive in the same way.
                The property used to fetch the condition as the input should have the same name as our directive.
    -ngSwitch:
        It is a builtin structural directive.
        It is used in the same way as the switch statement in c or c++ or in any other language.
        Its syntax can be explained using an example:
            <div [ngSwitch]="value">        // here value is assigned a value in the typescript file
                <p *ngSwitchCase="5">Value is 5</p>
                <p *ngSwitchCase="10">Value is 10</p>
                <p *ngSwitchCase="15">Value is 15</p>
                <p *ngSwitchDefault>Value is Default</p>
            </div>
            Here, ngSwitch is used using property binding and accepts a value.
            ngSwitch then matches the value with all the values stated in the ngSwitchCase.
            Whichever value matches, That element stays in the DOM, rest are removed.
            If no value matches, ngSwitchDefault stays in the DOM, rest are removed.

-Service:
    Creating a service:
        Create a file named 'serviceName.service.ts' in a suitable location inside the app folder.
        Inside the service.ts file, simply create a class with name 'serviceNameService'.
        Inside this class, create and define the methods which you want your service to have.
    Using the service:
        To use this service inside any component, do the following:
            import { serviceNameService } from 'serviceLocation';
            Add the following property inside the @Component decorator argument:
                providers: [ serviceName ]
            In the constructor of the component, pass the following argument:
                constructor(private serviceNameProp: serviecNameService) {}
            To use a service method inside the class, type the following:
                this.serviceNameProp.methodName();
        Now for the working of the above mensioned steps:
            Angular is informed that our component needs to use a service, by passing the service as an argument in the constructor of the component as shown above.
            Now angular knows that our component needs the mensioned service, now where does angular get it from...
            A dependency injector comes into act when angular needs something, it injects the service into the component.
            For injecting the service into our component, we need to tell angular the provider of the service from where the dependency injector will inject the service.
            As mensioned in above steps, we add the provider to our service in the @Component decorator arguement.
            The provider also needs to be imported into the component, hence the import statement at the top.
    Understanding the Hierchical Injector:
        It is responsible to inject the instance of our service into our component.
        Its availability of the instance of the service is mensionsed below with the reference to where it was instantiated:
            AppModule: same instance of service is available Application-Wide.
            AppComponent: same instance of service is available for all components(but not for other services).
            Any other component: Same instance of service is available for the component and all its child components.
        To use a parent instance of a service in a component:
            Simply remove the service from the providers array.
            Now a new instance for the service wont be created, the component will be using the parent instance of the service.
            The import and constructor do needs to include the service, just providers doesn't need it.
    Using a service inside a service:
        To do so, do the following:
            Make sure that the service we want to inject is instantiated in the app.module.ts file.
            Go to the service.ts file where you want to inject another service.
            In this file, import the service which is to be injected as we do in other components.
            On top of the class, add a @Injectable decorator which tells angular that this service will recieve another service which is to be injected into this service. Injectable needs to be imported from '@angular/core'.
            Now we can use the methods of the injected service as we do in components.

-Routing:
    Routing provides the functionality to our angular app, to navigate between different components at a time.
    To setup routing:
        While creating a new project, AngularCLI will ask you to enable routing for your app, simply type 'y'.
        This will generate a file named 'app-routing.module.ts' in the root of the app folder.
        This file will be automatically imported into 'app.module.ts' file and 'AppRoutingModule' import will be automatically added via CLI.
        Now, to set routes for our component, follow the steps:
            Goto 'app-routing.module.ts' file.
            There will be an array declared as 'const routes: Routes = [];'.
            This array contains all the route paths for our components.
            So to setup the paths, add the path and componentName in this array as shown below:
                const routes: Routes = [
                    { path: 'url1', component: 'componentName1'},
                    { path: 'url2', component: 'componentName2'},
                ];
    To load components via routing:
        In the 'app.component.html' file, wherever there are buttons to load the specified component, inside the <a> tag, add the following attribute:
            <a routerLink="/">      or      <a routerLink="/path">      or      <a [routerLink]="['/path']">
    Routing Path:
        A component is loaded by specifying the path in the routerLink attribute.
        There are different ways of specifying the path which may lead to different paths:
            "/path": absolute path, will load localhost:4200/path.
            "path" or "./path": relative path, add path to the current path and then load it.
            "../path": will go up one level on the path and then add path to it and then load it.
    To change the highlighted opened tab for the component dynamically:
        After 'routerLink', add another attribute named 'routerLinkActive'.
        This accepts a class name as the value as applies that class onto the component tab which is active.
        When using routerLinkActive, we find that the home tab has that class always applied.
        This is because routerLinkActive works in a way that if a section of path contains the url of the component, the class will then be applied on that component tab as well.
        So to change this behavior of routerLinkActive, we use [routerLinkActiveOptions], with property binding.
        routerLinkActiveOptions helps us to configure the behavior of routerLinkActive.
        To change the above mensioned behavior of routerLinkActive, pass the value in routerLinkActiveOptions as follows:
            [routerLinkActiveOptions]="{exact: true}"
            This will inform routerLinkActive that apply the class only if the path exactly matches.
    Navigating Programatically:
        We can also navigate to a route from the typescript file.
        For example: 
            We add a button and (click)="funcName()" in it.
            In the typescript file, we need to do the following:
                import { Router } from '@angular/router';
                constructor(private router: Router) {}
            Now in the funcName, we do the following:
                this.router.navigate(['/path']);
            This will enable us to goto the component at the mensioned path on cliking the button.
        Using Relative Paths in Programatic Navigation:
            If we try to use the relative route(without '/') for the path, by default, it works in the same way as the absolute route.
            The navigate() function doesn't know currently at which path we are. So by default, it is going to relate the path from the root.
            To set a relative path, i.e. to let navigate() know our current path, we do the following:
                import { Router } from '@angular/router';
                constructor(private router: Router, private route: ActivatedRoute) {}
                this.router.navigate(['relativePath'], {navigate: this.route});
            ActivatedRoute enables navigate() to know about our current path.
            The js object in the argument of navigate(), 'navigate' sets the relative route for navigate().
    Passing parameters to routes:
        We can pass parameters to our routes so that we can load a dynamic route.
        To do so:
            const appRoutes: Routes = [
                { path: 'path/:id/:name', component: AnyComponent },      // here id and name are dynamic parameters
            ]
        To fetch the route parameters: 
            In the typescript file, do the following:
                import { ActivatedRoute } from '@angular/router';
                constructor(private route: ActivatedRoute) {}
                this.id  = this.route.snapshot.params['id'];            // this.id is a local property of the typescript file
                this.name = this.route.snapshot.params['name'];         // this.name is a local property of the typescript file
                Here, snapshot.params[''] is a method which helps us to retrieve the data which was stored in the dynamic parameters of the path.